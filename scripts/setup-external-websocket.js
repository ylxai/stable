#!/usr/bin/env node

/**
 * Setup External WebSocket Configuration
 * Configures the application to use your VPS WebSocket server
 */

const fs = require('fs');
const path = require('path');

// Your VPS WebSocket configuration
const EXTERNAL_WS_CONFIG = {
  url: 'https://xcyrexmwrwjq.ap-southeast-1.clawcloudrun.com',
  healthEndpoint: 'https://xcyrexmwrwjq.ap-southeast-1.clawcloudrun.com/health',
  wsEndpoint: 'https://xcyrexmwrwjq.ap-southeast-1.clawcloudrun.com/ws'
};

console.log('üîß Setting up External WebSocket Configuration...\n');

// 1. Update .env.local
function updateEnvLocal() {
  console.log('1Ô∏è‚É£ Updating .env.local...');
  
  const envLocalPath = path.join(process.cwd(), '.env.local');
  const envContent = `# External WebSocket Server Configuration
# Generated by setup-external-websocket.js

# Your VPS WebSocket Server
NEXT_PUBLIC_WS_URL=${EXTERNAL_WS_CONFIG.url}
NEXT_PUBLIC_SOCKETIO_URL=${EXTERNAL_WS_CONFIG.url}
NEXT_PUBLIC_USE_SOCKETIO=true

# Fallback Configuration
NEXT_PUBLIC_ENABLE_FALLBACK=true
NEXT_PUBLIC_POLLING_ENABLED=true

# WebSocket Health Check
NEXT_PUBLIC_WS_HEALTH_URL=${EXTERNAL_WS_CONFIG.healthEndpoint}

# Generated at: ${new Date().toISOString()}
`;

  try {
    fs.writeFileSync(envLocalPath, envContent);
    console.log('‚úÖ .env.local updated successfully');
    console.log(`   WebSocket URL: ${EXTERNAL_WS_CONFIG.url}`);
    console.log(`   Health URL: ${EXTERNAL_WS_CONFIG.healthEndpoint}`);
  } catch (error) {
    console.log('‚ùå Failed to update .env.local:', error.message);
  }
}

// 2. Create Vercel environment configuration
function createVercelConfig() {
  console.log('\n2Ô∏è‚É£ Creating Vercel environment configuration...');
  
  const vercelEnvConfig = {
    development: {
      NEXT_PUBLIC_WS_URL: EXTERNAL_WS_CONFIG.url,
      NEXT_PUBLIC_SOCKETIO_URL: EXTERNAL_WS_CONFIG.url,
      NEXT_PUBLIC_USE_SOCKETIO: 'true',
      NEXT_PUBLIC_ENABLE_FALLBACK: 'true',
      NEXT_PUBLIC_POLLING_ENABLED: 'true'
    },
    preview: {
      NEXT_PUBLIC_WS_URL: EXTERNAL_WS_CONFIG.url,
      NEXT_PUBLIC_SOCKETIO_URL: EXTERNAL_WS_CONFIG.url,
      NEXT_PUBLIC_USE_SOCKETIO: 'true',
      NEXT_PUBLIC_ENABLE_FALLBACK: 'true',
      NEXT_PUBLIC_POLLING_ENABLED: 'true'
    },
    production: {
      NEXT_PUBLIC_WS_URL: EXTERNAL_WS_CONFIG.url,
      NEXT_PUBLIC_SOCKETIO_URL: EXTERNAL_WS_CONFIG.url,
      NEXT_PUBLIC_USE_SOCKETIO: 'true',
      NEXT_PUBLIC_ENABLE_FALLBACK: 'true',
      NEXT_PUBLIC_POLLING_ENABLED: 'true'
    }
  };
  
  const configPath = path.join(process.cwd(), 'vercel-websocket-config.json');
  
  try {
    fs.writeFileSync(configPath, JSON.stringify(vercelEnvConfig, null, 2));
    console.log('‚úÖ Vercel configuration created: vercel-websocket-config.json');
  } catch (error) {
    console.log('‚ùå Failed to create Vercel config:', error.message);
  }
}

// 3. Generate Vercel CLI commands
function generateVercelCommands() {
  console.log('\n3Ô∏è‚É£ Generating Vercel CLI commands...');
  
  const commands = [
    `# Set WebSocket environment variables in Vercel`,
    `vercel env add NEXT_PUBLIC_WS_URL production`,
    `# When prompted, enter: ${EXTERNAL_WS_CONFIG.url}`,
    ``,
    `vercel env add NEXT_PUBLIC_SOCKETIO_URL production`,
    `# When prompted, enter: ${EXTERNAL_WS_CONFIG.url}`,
    ``,
    `vercel env add NEXT_PUBLIC_USE_SOCKETIO production`,
    `# When prompted, enter: true`,
    ``,
    `vercel env add NEXT_PUBLIC_ENABLE_FALLBACK production`,
    `# When prompted, enter: true`,
    ``,
    `vercel env add NEXT_PUBLIC_POLLING_ENABLED production`,
    `# When prompted, enter: true`,
    ``,
    `# Deploy with new configuration`,
    `vercel --prod`
  ];
  
  const commandsPath = path.join(process.cwd(), 'vercel-setup-commands.sh');
  
  try {
    fs.writeFileSync(commandsPath, commands.join('\n'));
    console.log('‚úÖ Vercel commands generated: vercel-setup-commands.sh');
    console.log('   Run these commands to set up Vercel environment variables');
  } catch (error) {
    console.log('‚ùå Failed to generate commands:', error.message);
  }
}

// 4. Create connection test component
function createConnectionTestComponent() {
  console.log('\n4Ô∏è‚É£ Creating connection test component...');
  
  const testComponent = `'use client';

/**
 * WebSocket Connection Test Component
 * Tests external WebSocket connection and displays status
 */

import React, { useState, useEffect } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Alert, AlertDescription } from '@/components/ui/alert';
import { 
  Wifi, 
  WifiOff, 
  CheckCircle, 
  AlertCircle, 
  RefreshCw,
  Activity,
  Globe
} from 'lucide-react';

interface ConnectionStatus {
  websocket: 'connected' | 'disconnected' | 'connecting' | 'error';
  socketio: 'connected' | 'disconnected' | 'connecting' | 'error';
  health: 'healthy' | 'unhealthy' | 'checking' | 'error';
  fallback: 'active' | 'inactive';
}

export function WebSocketConnectionTest() {
  const [status, setStatus] = useState<ConnectionStatus>({
    websocket: 'disconnected',
    socketio: 'disconnected',
    health: 'checking',
    fallback: 'inactive'
  });
  
  const [isLoading, setIsLoading] = useState(false);
  const [lastCheck, setLastCheck] = useState<Date | null>(null);
  const [error, setError] = useState<string | null>(null);

  // Test health endpoint
  const testHealthEndpoint = async () => {
    try {
      setStatus(prev => ({ ...prev, health: 'checking' }));
      
      const response = await fetch('${EXTERNAL_WS_CONFIG.healthEndpoint}');
      
      if (response.ok) {
        setStatus(prev => ({ ...prev, health: 'healthy' }));
        return true;
      } else {
        setStatus(prev => ({ ...prev, health: 'unhealthy' }));
        return false;
      }
    } catch (error) {
      setStatus(prev => ({ ...prev, health: 'error' }));
      setError(\`Health check failed: \${error.message}\`);
      return false;
    }
  };

  // Test WebSocket connection
  const testWebSocketConnection = async () => {
    try {
      setStatus(prev => ({ ...prev, websocket: 'connecting' }));
      
      const ws = new WebSocket('${EXTERNAL_WS_CONFIG.url.replace('https://', 'wss://')}/ws');
      
      return new Promise((resolve) => {
        const timeout = setTimeout(() => {
          ws.close();
          setStatus(prev => ({ ...prev, websocket: 'error' }));
          resolve(false);
        }, 10000);

        ws.onopen = () => {
          clearTimeout(timeout);
          setStatus(prev => ({ ...prev, websocket: 'connected' }));
          ws.close();
          resolve(true);
        };

        ws.onerror = () => {
          clearTimeout(timeout);
          setStatus(prev => ({ ...prev, websocket: 'error' }));
          resolve(false);
        };
      });
    } catch (error) {
      setStatus(prev => ({ ...prev, websocket: 'error' }));
      return false;
    }
  };

  // Test Socket.IO connection
  const testSocketIOConnection = async () => {
    try {
      setStatus(prev => ({ ...prev, socketio: 'connecting' }));
      
      // Import Socket.IO client dynamically
      const { io } = await import('socket.io-client');
      
      const socket = io('${EXTERNAL_WS_CONFIG.url}', {
        transports: ['websocket', 'polling'],
        timeout: 10000,
        reconnection: false
      });

      return new Promise((resolve) => {
        const timeout = setTimeout(() => {
          socket.disconnect();
          setStatus(prev => ({ ...prev, socketio: 'error' }));
          resolve(false);
        }, 15000);

        socket.on('connect', () => {
          clearTimeout(timeout);
          setStatus(prev => ({ ...prev, socketio: 'connected' }));
          socket.disconnect();
          resolve(true);
        });

        socket.on('connect_error', () => {
          clearTimeout(timeout);
          setStatus(prev => ({ ...prev, socketio: 'error' }));
          socket.disconnect();
          resolve(false);
        });
      });
    } catch (error) {
      setStatus(prev => ({ ...prev, socketio: 'error' }));
      return false;
    }
  };

  // Run all tests
  const runConnectionTests = async () => {
    setIsLoading(true);
    setError(null);
    
    try {
      const healthOk = await testHealthEndpoint();
      
      if (healthOk) {
        await Promise.all([
          testWebSocketConnection(),
          testSocketIOConnection()
        ]);
      }
      
      // Check if fallback is needed
      const needsFallback = status.websocket !== 'connected' && status.socketio !== 'connected';
      setStatus(prev => ({ 
        ...prev, 
        fallback: needsFallback ? 'active' : 'inactive' 
      }));
      
      setLastCheck(new Date());
    } catch (error) {
      setError(\`Connection test failed: \${error.message}\`);
    } finally {
      setIsLoading(false);
    }
  };

  // Auto-test on mount
  useEffect(() => {
    runConnectionTests();
  }, []);

  const getStatusIcon = (statusValue: string) => {
    switch (statusValue) {
      case 'connected':
      case 'healthy':
        return <CheckCircle className="h-4 w-4 text-green-500" />;
      case 'connecting':
      case 'checking':
        return <RefreshCw className="h-4 w-4 text-blue-500 animate-spin" />;
      case 'active':
        return <Activity className="h-4 w-4 text-orange-500" />;
      case 'inactive':
        return <CheckCircle className="h-4 w-4 text-green-500" />;
      default:
        return <AlertCircle className="h-4 w-4 text-red-500" />;
    }
  };

  const getStatusBadge = (statusValue: string, label: string) => {
    const variants = {
      connected: 'default',
      healthy: 'default',
      active: 'secondary',
      inactive: 'outline',
      connecting: 'secondary',
      checking: 'secondary',
      disconnected: 'destructive',
      unhealthy: 'destructive',
      error: 'destructive'
    };

    return (
      <Badge variant={variants[statusValue] || 'destructive'} className="flex items-center gap-1">
        {getStatusIcon(statusValue)}
        {label}
      </Badge>
    );
  };

  return (
    <Card className="w-full">
      <CardHeader>
        <CardTitle className="flex items-center gap-2">
          <Globe className="h-5 w-5" />
          External WebSocket Connection Test
        </CardTitle>
      </CardHeader>
      
      <CardContent className="space-y-4">
        {error && (
          <Alert variant="destructive">
            <AlertCircle className="h-4 w-4" />
            <AlertDescription>{error}</AlertDescription>
          </Alert>
        )}

        {/* Connection Status */}
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
          <div className="space-y-3">
            <div className="flex items-center justify-between">
              <span className="text-sm font-medium">Health Check</span>
              {getStatusBadge(status.health, status.health.toUpperCase())}
            </div>
            
            <div className="flex items-center justify-between">
              <span className="text-sm font-medium">WebSocket</span>
              {getStatusBadge(status.websocket, status.websocket.toUpperCase())}
            </div>
          </div>
          
          <div className="space-y-3">
            <div className="flex items-center justify-between">
              <span className="text-sm font-medium">Socket.IO</span>
              {getStatusBadge(status.socketio, status.socketio.toUpperCase())}
            </div>
            
            <div className="flex items-center justify-between">
              <span className="text-sm font-medium">Fallback Mode</span>
              {getStatusBadge(status.fallback, status.fallback.toUpperCase())}
            </div>
          </div>
        </div>

        {/* Server Info */}
        <div className="p-3 bg-gray-50 rounded-lg">
          <h4 className="font-medium mb-2">Server Configuration</h4>
          <div className="space-y-1 text-sm text-gray-600">
            <div>URL: ${EXTERNAL_WS_CONFIG.url}</div>
            <div>Health: ${EXTERNAL_WS_CONFIG.healthEndpoint}</div>
            <div>WebSocket: ${EXTERNAL_WS_CONFIG.url.replace('https://', 'wss://')}/ws</div>
          </div>
        </div>

        {/* Actions */}
        <div className="flex items-center justify-between">
          <div className="text-sm text-gray-500">
            {lastCheck && \`Last checked: \${lastCheck.toLocaleTimeString()}\`}
          </div>
          
          <Button
            onClick={runConnectionTests}
            disabled={isLoading}
            variant="outline"
            size="sm"
          >
            <RefreshCw className={\`h-4 w-4 mr-2 \${isLoading ? 'animate-spin' : ''}\`} />
            Test Connection
          </Button>
        </div>
      </CardContent>
    </Card>
  );
}`;

  const componentPath = path.join(process.cwd(), 'src/components/admin/websocket-connection-test.tsx');
  
  try {
    fs.writeFileSync(componentPath, testComponent);
    console.log('‚úÖ Connection test component created: src/components/admin/websocket-connection-test.tsx');
  } catch (error) {
    console.log('‚ùå Failed to create test component:', error.message);
  }
}

// 5. Update next.config.js for WebSocket support
function updateNextConfig() {
  console.log('\n5Ô∏è‚É£ Updating next.config.js for WebSocket support...');
  
  const nextConfigPath = path.join(process.cwd(), 'next.config.js');
  
  try {
    let nextConfig = fs.readFileSync(nextConfigPath, 'utf8');
    
    // Add WebSocket configuration if not already present
    if (!nextConfig.includes('webSocketURL')) {
      const wsConfig = `
  // External WebSocket Configuration
  env: {
    NEXT_PUBLIC_WS_URL: process.env.NEXT_PUBLIC_WS_URL,
    NEXT_PUBLIC_SOCKETIO_URL: process.env.NEXT_PUBLIC_SOCKETIO_URL,
    NEXT_PUBLIC_USE_SOCKETIO: process.env.NEXT_PUBLIC_USE_SOCKETIO,
  },
  
  // WebSocket proxy for development
  async rewrites() {
    return [
      {
        source: '/ws/:path*',
        destination: '${EXTERNAL_WS_CONFIG.url}/ws/:path*',
      },
    ];
  },`;
      
      // Insert before the closing brace
      nextConfig = nextConfig.replace(/}\s*$/, `${wsConfig}\n}`);
      
      fs.writeFileSync(nextConfigPath, nextConfig);
      console.log('‚úÖ next.config.js updated with WebSocket configuration');
    } else {
      console.log('‚úÖ next.config.js already has WebSocket configuration');
    }
  } catch (error) {
    console.log('‚ùå Failed to update next.config.js:', error.message);
  }
}

// Main setup function
async function setupExternalWebSocket() {
  console.log('üöÄ External WebSocket Setup');
  console.log('===========================\n');
  
  try {
    updateEnvLocal();
    createVercelConfig();
    generateVercelCommands();
    createConnectionTestComponent();
    updateNextConfig();
    
    console.log('\nüéâ External WebSocket setup completed successfully!');
    console.log('\nüìù Next steps:');
    console.log('   1. Run: npm run dev (to test locally)');
    console.log('   2. Run: node scripts/test-external-websocket.js (to test connection)');
    console.log('   3. Set Vercel environment variables using vercel-setup-commands.sh');
    console.log('   4. Deploy: vercel --prod');
    console.log('\nüîß Files created/updated:');
    console.log('   - .env.local');
    console.log('   - vercel-websocket-config.json');
    console.log('   - vercel-setup-commands.sh');
    console.log('   - src/components/admin/websocket-connection-test.tsx');
    console.log('   - next.config.js (updated)');
    
  } catch (error) {
    console.error('\n‚ùå Setup failed:', error.message);
  }
}

// Run setup if called directly
if (require.main === module) {
  setupExternalWebSocket().catch(console.error);
}

module.exports = {
  setupExternalWebSocket,
  EXTERNAL_WS_CONFIG
};